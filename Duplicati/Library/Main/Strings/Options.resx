<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AutocleanupLong" xml:space="preserve">
    <value>If a backup is interrupted there will likely be partial files present on the backend. Using this flag, Duplicati will automatically remove such files when encountered.</value>
  </data>
  <data name="AutocleanupShort" xml:space="preserve">
    <value>A flag indicating that Duplicati should remove unused files</value>
  </data>
  <data name="PrefixLong" xml:space="preserve">
    <value>A string used to prefix the filenames of the remote volumes, can be used to store multiple backups in the same remote folder.</value>
  </data>
  <data name="PrefixShort" xml:space="preserve">
    <value>Remote filename prefix</value>
  </data>
  <data name="DisablefiletimecheckLong" xml:space="preserve">
    <value>The operating system keeps track of the last time a file was written. Using this information, Duplicati can quickly determine if the file has been modified. If some application deliberately modifies this information, Duplicati won't work correctly unless this flag is set.</value>
  </data>
  <data name="DisablefiletimecheckShort" xml:space="preserve">
    <value>Disable checks based on file time</value>
  </data>
  <data name="RestorepathLong" xml:space="preserve">
    <value>By default, files will be restored in the source folders, use this option to restore to another folder</value>
  </data>
  <data name="RestorepathShort" xml:space="preserve">
    <value>Restore to another folder</value>
  </data>
  <data name="AllowsleepShort" xml:space="preserve">
    <value>Allow system to enter sleep power modes for inactivity during backup/restore operations (Windows only)</value>
  </data>
  <data name="ThrottledownloadLong" xml:space="preserve">
    <value>By setting this value you can limit how much bandwidth Duplicati consumes for downloads. Setting this limit can make the backups take longer, but will make Duplicati less intrusive.</value>
  </data>
  <data name="ThrottledownloadShort" xml:space="preserve">
    <value>Max number of kilobytes to download pr. second</value>
  </data>
  <data name="ThrottleuploadLong" xml:space="preserve">
    <value>By setting this value you can limit how much bandwidth Duplicati consumes for uploads. Setting this limit can make the backups take longer, but will make Duplicati less intrusive.</value>
  </data>
  <data name="ThrottleuploadShort" xml:space="preserve">
    <value>Max number of kilobytes to upload pr. second</value>
  </data>
  <data name="NoencryptionLong" xml:space="preserve">
    <value>If you store the backups on a local disk, and prefer that they are kept unencrypted, you can turn of encryption completely by using this switch.</value>
  </data>
  <data name="NoencryptionShort" xml:space="preserve">
    <value>Disable encryption</value>
  </data>
  <data name="NumberofretriesLong" xml:space="preserve">
    <value>If an upload or download fails, Duplicati will retry a number of times before failing. Use this to handle unstable network connections better.</value>
  </data>
  <data name="NumberofretriesShort" xml:space="preserve">
    <value>Number of times to retry a failed transmission</value>
  </data>
  <data name="PassphraseLong" xml:space="preserve">
    <value>Supply a passphrase that Duplicati will use to encrypt the backup volumes, making them unreadable without the passphrase. This variable can also be supplied through the environment variable PASSPHRASE.</value>
  </data>
  <data name="PassphraseShort" xml:space="preserve">
    <value>Passphrase used to encrypt backups</value>
  </data>
  <data name="TimeLong" xml:space="preserve">
    <value>By default, Duplicati will list and restore files from the most recent backup, use this option to select another item. You may use relative times, like "-2M" for a backup from two months ago.</value>
  </data>
  <data name="TimeShort" xml:space="preserve">
    <value>The time to list/restore files</value>
  </data>
  <data name="VersionLong" xml:space="preserve">
    <value>By default, Duplicati will list and restore files from the most recent backup, use this option to select another item. You may enter multiple values separated with comma, and ranges using -, e.g. "0,2-4,7" .</value>
  </data>
  <data name="VersionShort" xml:space="preserve">
    <value>The version to list/restore files</value>
  </data>
  <data name="AllversionsLong" xml:space="preserve">
    <value>When searching for files, only the most recent backup is searched. Use this option to show all previous versions too.</value>
  </data>
  <data name="AllversionsShort" xml:space="preserve">
    <value>Show all versions</value>
  </data>
  <data name="ListprefixonlyLong" xml:space="preserve">
    <value>When searching for files, all matching files are returned. Use this option to return only the largest common prefix path.</value>
  </data>
  <data name="ListprefixonlyShort" xml:space="preserve">
    <value>Show largest prefix</value>
  </data>
  <data name="ListfoldercontentsLong" xml:space="preserve">
    <value>When searching for files, all matching files are returned. Use this option to return only the entries found in the folder specified as filter.</value>
  </data>
  <data name="ListfoldercontentsShort" xml:space="preserve">
    <value>Show folder contents</value>
  </data>
  <data name="RetrydelayLong" xml:space="preserve">
    <value>After a failed transmission, Duplicati will wait a short period before attempting again. This is usefull if the network drops out occasionally during transmissions.</value>
  </data>
  <data name="RetrydelayShort" xml:space="preserve">
    <value>Time to wait between retries</value>
  </data>
  <data name="ControlfilesLong" xml:space="preserve">
    <value>Use this option to attach extra files to the newly uploaded filelists.</value>
  </data>
  <data name="ControlfilesShort" xml:space="preserve">
    <value>Set control files</value>
  </data>
  <data name="SkipfilehashchecksLong" xml:space="preserve">
    <value>If the hash for the volume does not match, Duplicati will refuse to use the backup. Supply this flag to allow Duplicati to proceed anyway.</value>
  </data>
  <data name="SkipfilehashchecksShort" xml:space="preserve">
    <value>Set this flag to skip hash checks</value>
  </data>
  <data name="SkipfileslargerthanLong" xml:space="preserve">
    <value>This option allows you to exclude files that are larger than the given value. Use this to prevent backups becoming extremely large.</value>
  </data>
  <data name="SkipfileslargerthanShort" xml:space="preserve">
    <value>Limit the size of files being backed up</value>
  </data>
  <data name="TempdirLong" xml:space="preserve">
    <value>Duplicati will use the system default temporary folder. This option can be used to supply an alternative folder for temporary storage.</value>
  </data>
  <data name="TempdirShort" xml:space="preserve">
    <value>Temporary storage folder</value>
  </data>
  <data name="ThreadpriorityLong" xml:space="preserve">
    <value>Selects another thread priority for the process. Use this to set Duplicati to be more or less CPU intensive.</value>
  </data>
  <data name="ThreadpriorityShort" xml:space="preserve">
    <value>Thread priority</value>
  </data>
  <data name="DblocksizeLong" xml:space="preserve">
    <value>This option can change the maximum size of dblock files. Changing the size can be useful if the backend has a limit on the size of each individual file</value>
  </data>
  <data name="DblocksizeShort" xml:space="preserve">
    <value>Limit the size of the volumes</value>
  </data>
  <data name="DisableStreamingLong" xml:space="preserve">
    <value>Enabling this option will disallow usage of the streaming interface, which means that transfer progress bars will not show, and bandwidth throttle settings will be ignored.</value>
  </data>
  <data name="DisableStreamingShort" xml:space="preserve">
    <value>Disables use of the streaming transfer method</value>
  </data>
  <data name="DontreadmanifestsLong" xml:space="preserve">
    <value>This option will make sure the contents of the manifest file are not read. This also implies that file hashes are not checked either. Use only for disaster recovery.</value>
  </data>
  <data name="DontreadmanifestsShort" xml:space="preserve">
    <value>An option that prevents verifying the manifests</value>
  </data>
  <data name="CompressionmoduleLong" xml:space="preserve">
    <value>Duplicati supports plugable compression modules. Use this option to select a module to use for compression. This is only applied when creating new volumes, when reading an existing file, the filename is used to select the compression module.</value>
  </data>
  <data name="CompressionmoduleShort" xml:space="preserve">
    <value>Select what module to use for compression</value>
  </data>
  <data name="EncryptionmoduleLong" xml:space="preserve">
    <value>Duplicati supports plugable encryption modules. Use this option to select a module to use for encryption. This is only applied when creating new volumes, when reading an existing file, the filename is used to select the encryption module.</value>
  </data>
  <data name="EncryptionmoduleShort" xml:space="preserve">
    <value>Select what module to use for encryption</value>
  </data>
  <data name="DisablemoduleLong" xml:space="preserve">
    <value>Supply one or more module names, separated by commas to unload them</value>
  </data>
  <data name="DisablemoduleShort" xml:space="preserve">
    <value>Disabled one or more modules</value>
  </data>
  <data name="EnablemoduleLong" xml:space="preserve">
    <value>Supply one or more module names, separated by commas to load them</value>
  </data>
  <data name="EnablemoduleShort" xml:space="preserve">
    <value>Enables one or more modules</value>
  </data>
  <data name="SnapshotpolicyLong" xml:space="preserve">
    <value>This settings controls the usage of snapshots, which allows Duplicati to backup files that are locked by other programs. If this is set to "off", Duplicati will not attempt to create a disk snapshot. Setting this to "auto" makes Duplicati attempt to create a snapshot, and fail silently if that was not allowed or supported. A setting of "on" will also make Duplicati attempt to create a snapshot, but will produce a warning message in the log if it fails. Setting it to "required" will make Duplicati abort the backup if the snapshot creation fails. On windows this uses the Volume Shadow Copy Services (VSS) and requires administrative privileges. On linux this uses Logical Volume Management (LVM) and requires root privileges.</value>
  </data>
  <data name="SnapshotpolicyShort" xml:space="preserve">
    <value>Controls the use of disk snapshots</value>
  </data>
  <data name="AsynchronousuploadfolderLong" xml:space="preserve">
    <value>The pre-generated volumes will be placed into the temporary folder by default, this option can set a different folder for placing the temporary volumes, despite the name, this also works for synchronous runs</value>
  </data>
  <data name="AsynchronousuploadfolderShort" xml:space="preserve">
    <value>The path where ready volumes are placed until uploaded</value>
  </data>
  <data name="AsynchronousuploadlimitLong" xml:space="preserve">
    <value>When performing asynchronous uploads, Duplicati will create volumes that can be uploaded. To prevent Duplicati from generating too many volumes, this option limits the number of pending uploads. Set to zero to disable the limit</value>
  </data>
  <data name="AsynchronousuploadlimitShort" xml:space="preserve">
    <value>The number of volumes to create ahead of time</value>
  </data>
  <data name="DebugoutputLong" xml:space="preserve">
    <value>Activating this option will make some error messages more verbose, which may help you track down a particular issue</value>
  </data>
  <data name="DebugoutputShort" xml:space="preserve">
    <value>Enables debugging output</value>
  </data>
  <data name="LogfileLong" xml:space="preserve">
    <value>Specifies the name of a while into which internal log information is written</value>
  </data>
  <data name="LogfileShort" xml:space="preserve">
    <value>Log internal information</value>
  </data>
  <data name="LoglevelLong" xml:space="preserve">
    <value>Specifies the amount of log information to write into the file specified by --log-file</value>
  </data>
  <data name="LoglevelShort" xml:space="preserve">
    <value>Log information level</value>
  </data>
  <data name="DisableautocreatefolderLong" xml:space="preserve">
    <value>If Duplicati detects that the target folder is missing, it will create it automatically. Activate this option to prevent automatic folder creation.</value>
  </data>
  <data name="DisableautocreatefolderShort" xml:space="preserve">
    <value>Disables automatic folder creation</value>
  </data>
  <data name="VssexcludewritersLong" xml:space="preserve">
    <value>Use this option to exclude faulty writers from a snapshot. This is equivalent to the -wx flag of the vshadow.exe tool, except that it only accepts writer class GUIDs, and not component names or instance GUIDs. Multiple GUIDs must be separated with a semicolon, and most forms of GUIDs are allowed, including with and without curly braces.</value>
  </data>
  <data name="VssexcludewritersShort" xml:space="preserve">
    <value>A semicolon separated list of guids of VSS writers to exclude (Windows only)</value>
  </data>
  <data name="UsnpolicyLong" xml:space="preserve">
    <value>This settings controls the usage of NTFS USN numbers, which allows Duplicati to obtain a list of files and folders much faster. If this is set to "off", Duplicati will not attempt to use USN. Setting this to "auto" makes Duplicati attempt to use USN, and fail silently if that was not allowed or supported. A setting of "on" will also make Duplicati attempt to use USN, but will produce a warning message in the log if it fails. Setting it to "required" will make Duplicati abort the backup if the USN usage fails. This feature is only supported on Windows and requires administrative privileges.</value>
  </data>
  <data name="UsnpolicyShort" xml:space="preserve">
    <value>Controls the use of NTFS Update Sequence Numbers</value>
  </data>
  <data name="DisableusndiffcheckLong" xml:space="preserve">
    <value>If USN is enabled the USN numbers are used to find all changed files since last backup. Use this option to disable the use of USN numbers, which will make Duplicati investigate all source files. This option is primarily intended for testing and should not be disabled in a production environment. If USN is not enabled, this option has no effect.</value>
  </data>
  <data name="DisableusndiffcheckShort" xml:space="preserve">
    <value>Disables changelist by USN numbers</value>
  </data>
  <data name="DisabletimetoleranceLong" xml:space="preserve">
    <value>When deciding if a full backup should be made or an old backup should be deleted, Duplicati will adjust the times by a small fraction to ensure that minor time differences do not interfer with expected operation. If the backup is set to produce a full backup each day, and a full backup is made at, say 12:00:01, and the backup is executed again at 12:00:00, a full day has not passed and thus an incremental backup is performed. To avoid this, Duplicati inserts a 1% tolerance (max 1 hour). Use this option to disable the tolerance, and use strict time checking</value>
  </data>
  <data name="DisabletimetoleranceShort" xml:space="preserve">
    <value>Deactivates tolerance when comparing times</value>
  </data>
  <data name="ListverifyuploadsLong" xml:space="preserve">
    <value>Some protocols, like FTP, and some servers have problems detecting an interrupted transfer and will assume that the transfer completed, even if it did not. If this option is enabled Duplicati will list the contents of the backend after each upload and verify that the file exists and has the expected size.</value>
  </data>
  <data name="ListverifyuploadsShort" xml:space="preserve">
    <value>Verify uploads by listing contents</value>
  </data>
  <data name="SynchronousuploadLong" xml:space="preserve">
    <value>Duplicati will upload files while scanning the disk and producing volumes, which usually makes the backup faster. Use this flag to turn the behavior off, so that Duplicati will wait for each volume to complete.</value>
  </data>
  <data name="SynchronousuploadShort" xml:space="preserve">
    <value>Upload files synchronously</value>
  </data>
  <data name="NoconnectionreuseLong" xml:space="preserve">
    <value>Duplicati will attempt to perform multiple operations on a single connection, as this avoids repeated login attempts, and thus speeds up the process. This option can be used to ensure that each operation is performed on a seperate connection</value>
  </data>
  <data name="NoconnectionreuseShort" xml:space="preserve">
    <value>Do not re-use connections</value>
  </data>
  <data name="DebugretryerrorsLong" xml:space="preserve">
    <value>When an error occurs, Duplicati will silently retry, and only report the number of retries. Enable this option to have the error messages displayed when a retry is performed.</value>
  </data>
  <data name="DebugretryerrorsShort" xml:space="preserve">
    <value>Show error messages when a retry is performed</value>
  </data>
  <data name="UploadUnchangedBackupsLong" xml:space="preserve">
    <value>If no files have changed, Duplicati will not upload a backup set. If the backup data is used to verify that a backup was executed, this option will make Duplicati upload a backupset even if it is empty</value>
  </data>
  <data name="UploadUnchangedBackupsShort" xml:space="preserve">
    <value>Upload empty backup files</value>
  </data>
  <data name="QuotasizeLong" xml:space="preserve">
    <value>This value can be used to set a known upper limit on the amount of space a backend has. If the backend reports the size itself, this value is ignored</value>
  </data>
  <data name="QuotasizeShort" xml:space="preserve">
    <value>A reported maximum storage</value>
  </data>
  <data name="SymlinkpolicyShort" xml:space="preserve">
    <value>Symlink handling</value>
  </data>
  <data name="SymlinkpolicyLong" xml:space="preserve">
    <value>Using this option to handle symlinks different. The "{0}" option will simply record a symlink with its name and destination, and a restore will recreate the symlink as a link. Use the option "{1}" to ignore all symlinks and not store any information about them. Previous versions of Duplicati used the setting "{2}", which will cause symlinked files to be included and restore as normal files.</value>
  </data>
  <data name="HardlinkpolicyShort" xml:space="preserve">
    <value>Hardlink handling</value>
  </data>
  <data name="HardlinkpolicyLong" xml:space="preserve">
    <value>Using this option to handle hardlinks (only works on Linux/OSX). The "{0}" option will record a hardlink ID for each hardlink to avoid storing hardlinked paths multiple times. The option "{1}" will ignore hardlink information, and treat each hardlink as a unique path. The option "{2}" will ignore all hardlinks with more than one link.</value>
  </data>
  <data name="ExcludefilesattributesShort" xml:space="preserve">
    <value>Exclude files by attribute</value>
  </data>
  <data name="ExcludefilesattributesLong" xml:space="preserve">
    <value>Use this option to exclude files with certain attributes. Use a comma separated list of attribute names to specify more that one. Possible values are: {0}</value>
  </data>
  <data name="VssusemappingLong" xml:space="preserve">
    <value>Activate this option to map VSS snapshots to a drive (similar to SUBST, using Win32 DefineDosDevice). This will create temporary drives that are then used to access the contents of a snapshot. This workaround can speed up file access on Windows XP.</value>
  </data>
  <data name="VssusemappingShort" xml:space="preserve">
    <value>Map snapshots to a drive (Windows only)</value>
  </data>
  <data name="BackupnameLong" xml:space="preserve">
    <value>A display name that is attached to this backup. Can be used to identify the backup when sending mail or running scripts.</value>
  </data>
  <data name="BackupnameShort" xml:space="preserve">
    <value>Name of the backup</value>
  </data>
  <data name="CompressionextensionfileLong" xml:space="preserve">
    <value>This property can be used to point to a text file where each line contains a file extension that indicates a non-compressible file. Files that have an extension found in the file will not be compressed, but simply stored in the archive. The file format ignores any lines that do not start with a period, and considers a space to indicate the end of the extension. A default file is supplied, that also serves as an example. The default file is placed in {0}.</value>
  </data>
  <data name="CompressionextensionfileShort" xml:space="preserve">
    <value>Manage non-compressible file extensions</value>
  </data>
  <data name="BlockhashlookupsizeLong" xml:space="preserve">
    <value>A fragment of memory is used to reduce database lookups. You should not change this value unless you get warnings in the log.</value>
  </data>
  <data name="BlockhashlookupsizeShort" xml:space="preserve">
    <value>Memory used by the block hash</value>
  </data>
  <data name="BlocksizeLong" xml:space="preserve">
    <value>The blocksize determines how files are fragmented. Choosing a large value will cause a larger overhead on file changes, choosing a small value will cause a large overhead on storage of file lists. Note that the value cannot be changed after remote files are created.</value>
  </data>
  <data name="BlocksizeShort" xml:space="preserve">
    <value>Blocksize used in hashing</value>
  </data>
  <data name="ChangedfilesLong" xml:space="preserve">
    <value>This option can be used to limit the scan to only files that are known to have changed. This is usually only activated in combination with a filesystem watcher that keeps track of file changes.</value>
  </data>
  <data name="ChangedfilesShort" xml:space="preserve">
    <value>List of files to examine for changes</value>
  </data>
  <data name="DbpathLong" xml:space="preserve">
    <value>Path to the file containing the local cache of the remote file database</value>
  </data>
  <data name="DbpathShort" xml:space="preserve">
    <value>Path to the local state database</value>
  </data>
  <data name="DeletedfilesLong" xml:space="preserve">
    <value>This option can be used to supply a list of deleted files. This option will be ignored unless the option --{0} is also set.</value>
  </data>
  <data name="DeletedfilesShort" xml:space="preserve">
    <value>List of deleted files</value>
  </data>
  <data name="FilehashlookupsizeLong" xml:space="preserve">
    <value>A fragment of memory is used to reduce database lookups. You should not change this value unless you get warnings in the log.</value>
  </data>
  <data name="FilehashlookupsizeShort" xml:space="preserve">
    <value>Memory used by the file hash</value>
  </data>
  <data name="DisablefilepathcacheShort" xml:space="preserve">
    <value>This option can be used to reduce the memory footprint by not keeping paths and scantimes in memory</value>
  </data>
  <data name="DisablefilepathcacheLong" xml:space="preserve">
    <value>Reduce memory footprint by disabling in-memory lookups</value>
  </data>
  <data name="StoremetadataLong" xml:space="preserve">
    <value>Stores metadata, such as file timestamps and attributes. This increases the required storage space as well as the processing time.</value>
  </data>
  <data name="StoremetadataShort" xml:space="preserve">
    <value>Enables storing file metadata</value>
  </data>
  <data name="MetadatahashlookupsizeLong" xml:space="preserve">
    <value>A fragment of memory is used to reduce database lookups. You should not change this value unless you get warnings in the log.</value>
  </data>
  <data name="MetadatahashlookupsizeShort" xml:space="preserve">
    <value>Memory used by the metadata hash</value>
  </data>
  <data name="NobackendverificationLong" xml:space="preserve">
    <value>If this flag is set, the local database is not compared to the remote filelist on startup. The intended usage for this option is to work correctly in cases where the filelisting is broken or unavailable.</value>
  </data>
  <data name="NobackendverificationShort" xml:space="preserve">
    <value>Do not query backend at startup</value>
  </data>
  <data name="IndexfilepolicyLong" xml:space="preserve">
    <value>The index files are used to limit the need for downloading dblock files when there is no local database present. The more information is recorded in the index files, the faster operations can proceed without the database. The tradeoff is that larger index files take up more remote space and which may never be used.</value>
  </data>
  <data name="IndexfilepolicyShort" xml:space="preserve">
    <value>Determines usage of index files</value>
  </data>
  <data name="ThresholdLong" xml:space="preserve">
    <value>As files are changed, some data stored at the remote destination may not be required. This option controls how much wasted space the destination can contain before being reclaimed. This value is a percentage used on each volume and the total storage.</value>
  </data>
  <data name="ThresholdShort" xml:space="preserve">
    <value>The maximum wasted space in percent</value>
  </data>
  <data name="DryrunLong" xml:space="preserve">
    <value>This option can be used to experiment with different settings and observe the outcome without changing actual files.</value>
  </data>
  <data name="DryrunShort" xml:space="preserve">
    <value>Does not perform any modifications</value>
  </data>
  <data name="BlockhashalgorithmLong" xml:space="preserve">
    <value>This is a very advanced option! This option can be used to select a block hash algorithm with smaller or larger hash size, for performance or storage space reasons.</value>
  </data>
  <data name="BlockhashalgorithmShort" xml:space="preserve">
    <value>The hash algorithm used on blocks</value>
  </data>
  <data name="FilehashalgorithmLong" xml:space="preserve">
    <value>This is a very advanced option! This option can be used to select a file hash algorithm with smaller or larger hash size, for performance or storage space reasons.</value>
  </data>
  <data name="FilehashalgorithmShort" xml:space="preserve">
    <value>The hash algorithm used on files</value>
  </data>
  <data name="NoautocompactLong" xml:space="preserve">
    <value>If a large number of small files are detected during a backup, or wasted space is found after deleting backups, the remote data will be compacted. Use this option to disable such automatic compacting and only compact when running the compact command.</value>
  </data>
  <data name="NoautocompactShort" xml:space="preserve">
    <value>Disable automatic compating</value>
  </data>
  <data name="SmallfilesizeLong" xml:space="preserve">
    <value>When examining the size of a volume in consideration for compating, a small tolerance value is used, by default 20 percent of the volume size. This ensures that large volumes which may have a few bytes wasted space are not downloaded and rewritten.</value>
  </data>
  <data name="SmallfilesizeShort" xml:space="preserve">
    <value>Volume size threshold</value>
  </data>
  <data name="SmallfilemaxcountLong" xml:space="preserve">
    <value>To avoid filling the remote storage with small files, this value can force grouping small files. The small volumes will always be combined when they can fill an entire volume.</value>
  </data>
  <data name="SmallfilemaxcountShort" xml:space="preserve">
    <value>Maximum number of small volumes</value>
  </data>
  <data name="PatchwithlocalblocksLong" xml:space="preserve">
    <value>Enable this option to look into other files on this machine to find existing blocks. This is a fairly slow operation but can limit the size of downloads.</value>
  </data>
  <data name="PatchwithlocalblocksShort" xml:space="preserve">
    <value>Use local file data when restoring</value>
  </data>
  <data name="NolocaldbShort" xml:space="preserve">
    <value>Disables the local database</value>
  </data>
  <data name="NolocaldbLong" xml:space="preserve">
    <value>When listing contents or when restoring files, the local database can be skipped. This is usually slower, but can be used to verify the actual contents of the remote store</value>
  </data>
  <data name="KeepversionsShort" xml:space="preserve">
    <value>Keep a number of versions</value>
  </data>
  <data name="KeepversionsLong" xml:space="preserve">
    <value>Use this option to set number of versions to keep, supply -1 to keep all versions</value>
  </data>
  <data name="KeeptimeShort" xml:space="preserve">
    <value>Keep all versions within a timespan</value>
  </data>
  <data name="KeeptimeLong" xml:space="preserve">
    <value>Use this option to set the timespan in which backups are kept.</value>
  </data>
  <data name="AllowmissingsourceShort" xml:space="preserve">
    <value>Ignore missing source elements</value>
  </data>
  <data name="AllowmissingsourceLong" xml:space="preserve">
    <value>Use this option to continue even if some source entries are missing.</value>
  </data>
  <data name="DownloadedFileSizeError" xml:space="preserve">
    <value>The file {0} was downloaded and had size {1} but the size was expected to be {2}</value>
  </data>
  <data name="OverwriteShort" xml:space="preserve">
    <value>Overwrite files when restoring</value>
  </data>
  <data name="OverwriteLong" xml:space="preserve">
    <value>Use this option to overwrite target files when restoring, if this option is not set the files will be restored with a timestamp and a number appended.</value>
  </data>
  <data name="VerboseShort" xml:space="preserve">
    <value>Output more progress information</value>
  </data>
  <data name="VerboseLong" xml:space="preserve">
    <value>Use this option to increase the amount of output generated when running an option. Generally this option will produce a line for each file processed.</value>
  </data>
  <data name="UploadverificationfileShort" xml:space="preserve">
    <value>Determine if verification files are uploaded</value>
  </data>
  <data name="UploadverificationfileLong" xml:space="preserve">
    <value>Use this option to upload a verification file after changing the remote storage. The file is not encrypted and contains the size and SHA256 hashes of all the remote files and can be used to verify the integrity of the files.</value>
  </data>
  <data name="BackendtestsamplesShort" xml:space="preserve">
    <value>The number of samples to test after a backup</value>
  </data>
  <data name="BackendtestsamplesLong" xml:space="preserve">
    <value>After a backup is completed, some files are selected for verification on the remote backend. Use this option to change how many. If this value is set to 0 or the option --{0} is set, no remote files are verified</value>
  </data>
  <data name="FullremoteverificationShort" xml:space="preserve">
    <value>Activates in-depth verification of files</value>
  </data>
  <data name="FullremoteverificationLong" xml:space="preserve">
    <value>After a backup is completed, some files are selected for verification on the remote backend. Use this option to turn on full verification, which will decrypt the files and examine the insides of each volume, instead of simply verifying the external hash, If the option --{0} is set, no remote files are verified</value>
  </data>
  <data name="FilereadbuffersizeShort" xml:space="preserve">
    <value>Size of the file read buffer</value>
  </data>
  <data name="FilereadbuffersizeLong" xml:space="preserve">
    <value>Use this size to control how many bytes a read from a file before processing</value>
  </data>
  <data name="AllowpassphrasechangeShort" xml:space="preserve">
    <value>Allow the passphrase to change</value>
  </data>
  <data name="AllowpassphrasechangeLong" xml:space="preserve">
    <value>Use this option to allow the passphrase to change, note that this option is not permitted for a backup or repair operation</value>
  </data>
  <data name="FullblockverificationLong" xml:space="preserve">
    <value>Verify encrypted blocks after they are downloaded</value>
  </data>
  <data name="FullblockverificationShort" xml:space="preserve">
    <value>Verify encrypted blocks</value>
  </data>
</root>